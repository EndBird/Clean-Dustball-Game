package game;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Random;
import java.util.Scanner;

import sprites.CleanHallway;
import sprites.Dirt;
import sprites.Dumpster;
import sprites.DustBall;
import sprites.Sprite;
import sprites.Vacuum;
import sprites.Wall;
import game.Constants;
import game.ArrayGrid;

/**
 * A class that represents the basic functionality of the vacuum game.
 * This class is responsible for performing the following operations:
 * 1. At creation, it initializes the instance variables used to store the
 *        current state of the game.
 * 2. When a move is specified, it checks if it is a legal move and makes the
 *        move if it is legal.
 * 3. It reports information about the current state of the game when asked.
 */
public class VacuumGame {

    // a random number generator to move the DustBalls
    private Random random;
   
    
    // the grid
    private Grid<Sprite> grid;

    // the first player
    private Vacuum vacuum1;

    /// the second player
    private Vacuum vacuum2;

    // the dirt (both static dirt and mobile dust balls)
    private List<Dirt> dirts; 

    // the dumpsters
    private List<Dumpster> dumpsters;
    
    private String[] vacuum1_moves = {"a","d","w","s"};
    private String[] vacuum2_moves = {"j", "l", "i","k"};
   
    /**
     * Creates a new VacuumGame that corresponds to the given input text file.
     * Assumes that the input file has one or more lines of equal lengths, and
     * that each character in it (other than newline) is a character that 
     * represents one of the sprites in this game.
     * @param layoutFileName path to the input grid file
     */
    public VacuumGame(String layoutFileName) throws IOException {
        this.dirts = new ArrayList<Dirt>();
        this.dumpsters = new ArrayList<Dumpster>(); // Jen: may not need this
        this.random = new Random();

        // open the file, read the contents, and determine 
        // dimensions of the grid
        int[] dimensions = getDimensions(layoutFileName);
        this.grid = new ArrayGrid<Sprite>(dimensions[0], dimensions[1]);

        // open the file again, read the contents, and store them in grid
        Scanner sc = new Scanner(new File(layoutFileName));

	// INITIALIZE THE GRID HERE
        String line = sc.nextLine();
        int i = 0; int j = 0; int k=dimensions[0]; int l = dimensions[1]; int m=0;
        for (i=0; i<k;i++) {for (j=0;j<l;j++){char content = line.charAt(m);
        if (content == 'X') {this.grid.setCell(i,j, new Wall('X', i, j));}
        else if (content == 'o') {this.grid.setCell(i,j, 
        		new DustBall('o', i, j, Constants.DUST_BALL_SCORE));
        this.dirts.add(this.grid.getCell(i,j));}
        else if (content == 'U') {this.grid.setCell(i,j, new Dumpster('U', i, j));
        this.dumpsters.add(this.grid.getCell(i,j));}
        else if (content == '.') {this.grid.setCell(i,j,
        		new Dirt('.', i, j, Constants.DIRT)); this.dirts.add(this.grid.getCell(i,j));}
        else if (content == '1') {this.grid.setCell(i,j,
        		new Vacuum('1',i,j,Constants.CAPACITY));
        this.grid.getCell(i,j).setUnder(new CleanHallway(' ', i,j));
        vacuum1 = this.grid.getCell(i,j);}
        else if (content == '2') {this.grid.set(i,j,
        		new Vacuum('1',i,j,Constants.CAPACITY));
        this.grid.getCell(i,j).setUnder(new CleanHallway(' ', i,j));
        vacuum2 = this.grid.getCell(i,j);}
        else {this.grid.setCell(i,j, new CleanHallway(' ', i,j));}
        m = m + 1;
        if (m>l) {m =0; line = sc.nextLine();} //end of line.  get nextline
        }
        	
        	
        }
        
        
        
        
        
        sc.close();
    }


    /**
     * Returns the dimensions of the grid in the file named layoutFileName.
     * @param layoutFileName path of the input grid file
     * @return an array [numRows, numCols], where numRows is the number
     * of rows and numCols is the number of columns in the grid that
     * corresponds to the given input grid file
     * @throws IOException
     */
    private int[] getDimensions(String layoutFileName) throws IOException {       

        Scanner sc = new Scanner(new File(layoutFileName));

        // find the number of columns
        String nextLine = sc.nextLine();
        int numCols = nextLine.length();

        int numRows = 1;

        // find the number of rows
        while (sc.hasNext()) {
            numRows++;
            nextLine = sc.nextLine();
        }

        sc.close();
        return new int[]{numRows, numCols};
    }
    
    private boolean is_dirt_or_hall(int i, int j){if (this.grid.getCell(i,j) instanceof Dirt || this.grid.getCell(i,j) instanceof CleanHallway){return true;} 
    else {return false;}}
    
    private List<int[]> DustBallLegalMoves(DustBall db) 
    {List<int[]> legal_moves = new ArrayList<int[]>(); int row = db.getRow(); int col = db.getColumn();
    int grid_col = this.grid.getNumColumns(); int grid_row = this.grid.getNumRows(); if (grid_row==1 && grid_col==1){return legal_moves;} //no legal moves
    else if (grid_col==1){
    	if (row ==0){if (this.is_dirt_or_hall(row+1, col)) { int[] move ={row+1,col}; legal_moves.add(move);
    
                                                      //i can move up or down
    return legal_moves;} else {return legal_moves;}} 
    else if (row<grid_row-1) {if (this.is_dirt_or_hall(row+1, col)) { int[] move ={row+1,col}; legal_moves.add(move);} if (this.is_dirt_or_hall(row-1, col)) { int[] move ={row-1,col}; legal_moves.add(move);} return legal_moves;}
    else {if (this.is_dirt_or_hall(row-1, col)) { int[] move ={row-1,col}; legal_moves.add(move);
    return legal_moves;} else {return legal_moves;}}}
    else if (grid_row==1){if (col ==0){if (this.is_dirt_or_hall(row, col+1)) { int[] move ={row,col+1}; legal_moves.add(move);
    
    //i can move left or right
    return legal_moves;} else {return legal_moves;}} 
    else if (col<grid_col-1) {if (this.is_dirt_or_hall(row, col+1)) { int[] move ={row,col+1}; legal_moves.add(move);} if (this.is_dirt_or_hall(row, col-1)) { int[] move ={row,col-1}; legal_moves.add(move);} return legal_moves;}
    else {if (this.is_dirt_or_hall(row, col-1)) { int[] move ={row,col-1}; legal_moves.add(move);
    return legal_moves;} else {return legal_moves;}}}
    else {return this.DustBallLegalMovesHelper(db,legal_moves,row,col,grid_col,grid_row);} }  //do i have to write return?
    
    
    private List<int[]> DustBallLegalMovesHelper(DustBall db, List<int[]> legal_moves, int row, int col, int grid_col, int grid_row) {
    if (row==0 && col==0) {if (this.is_dirt_or_hall(row, col+1)){int[] move ={row,col+1}; legal_moves.add(move);} 
    if (this.is_dirt_or_hall(row+1, col)){int[] move ={row+1,col}; legal_moves.add(move);} return legal_moves; }
    
    
    else if (row==0 && col==grid_col-1) {if (this.is_dirt_or_hall(row, col-1)){int[] move ={row,col-1}; legal_moves.add(move);} 
    if (this.is_dirt_or_hall(row+1, col)){int[] move ={row+1,col}; legal_moves.add(move);} return legal_moves;}
    else if (row==0) {if (this.is_dirt_or_hall(row, col+1)){int[] move ={row,col+1}; legal_moves.add(move);} 
    if (this.is_dirt_or_hall(row+1, col)){int[] move ={row+1,col}; legal_moves.add(move);} if (this.is_dirt_or_hall(row, col-1)){int[] move ={row,col-1}; legal_moves.add(move);} return legal_moves;}   
    else if (col==0 && row==grid_row-1) {if (this.is_dirt_or_hall(row, col+1)){int[] move ={row,col+1}; legal_moves.add(move);} 
    if (this.is_dirt_or_hall(row-1, col)){int[] move ={row-1,col}; legal_moves.add(move);} return legal_moves;}
    else if (col==0) {if (this.is_dirt_or_hall(row, col+1)){int[] move ={row,col+1}; legal_moves.add(move);} 
    if (this.is_dirt_or_hall(row+1, col)){int[] move ={row+1,col}; legal_moves.add(move);} if (this.is_dirt_or_hall(row-1, col)){int[] move ={row-1,col}; legal_moves.add(move);} return legal_moves;}
    else if (row==grid_row-1 && col==grid_col-1) {if (this.is_dirt_or_hall(row, col-1)){int[] move ={row,col-1}; legal_moves.add(move);} 
    if (this.is_dirt_or_hall(row-1, col)){int[] move ={row-1,col}; legal_moves.add(move);} return legal_moves;}   
    else if (row == grid_row-1) {if (this.is_dirt_or_hall(row, col+1)){int[] move ={row,col+1}; legal_moves.add(move);} 
    if (this.is_dirt_or_hall(row, col-1)){int[] move ={row,col-1}; legal_moves.add(move);} if (this.is_dirt_or_hall(row-1, col)){int[] move ={row-1,col}; legal_moves.add(move);} return legal_moves;}
    else if (col == grid_col-1) {if (this.is_dirt_or_hall(row, col-1)){int[] move ={row,col-1}; legal_moves.add(move);} 
    if (this.is_dirt_or_hall(row+1, col)){int[] move ={row+1,col}; legal_moves.add(move);} if (this.is_dirt_or_hall(row-1, col)){int[] move ={row-1,col}; legal_moves.add(move);} return legal_moves;}
    else {if (this.is_dirt_or_hall(row, col+1)){int[] move ={row,col+1}; legal_moves.add(move);} if (this.is_dirt_or_hall(row, col-1)){int[] move ={row,col-1}; legal_moves.add(move);} 
    if (this.is_dirt_or_hall(row+1, col)){int[] move ={row+1,col}; legal_moves.add(move);} if (this.is_dirt_or_hall(row-1, col)){int[] move ={row-1,col}; legal_moves.add(move);} return legal_moves;} 
    }
    
    private void DustballMove() {if (this.grid.getNumRows()==1 && this.grid.getNumColumns()==1){return;} //can't move
    List<Dirt> dirt_list = this.dirts; int dirt_list_size = this.dirts.size();  List<DustBall> db_list;
    for (int i=0; i<dirt_list_size; i++) {if (dirt_list.get(i) instanceof DustBall) {db_list.add(dirt_list.get(i));}}
    int db_list_size = db_list.size();   for (int i=0; i<db_list_size; i++) {DustBall current_db =  db_list.get(i);
    List<int[]> current_db_legal_moves = DustBallLegalMoves(current_db); int current_db_legal_moves_size = current_db_legal_moves.size();
    int ran_num = random.nextInt(current_db_legal_moves_size); int[] db_move = current_db_legal_moves.get(ran_num); 
    if (this.grid.getCell(db_move[0],db_move[1]) instanceof CleanHallway) {Dirt new_dirt = new Dirt('.', db_move[0],db_move[1],Constants.DIRT_SCORE); dirt_list.add(-1, new_dirt);} 
    this.grid.setCell(db_move[0],db_move[1], current_db); Dirt new_dirt = new Dirt('.', current_db.getRow(),current_db.getColumn(),Constants.DIRT_SCORE); this.grid.setCell(current_db.getRow(),current_db.getColumn(), new_dirt); 
    if (dirt_list.contains(new_dirt) == false) {dirt_list.add(new_dirt);} current_db.moveTo(db_move[0], db_move[1]); 
    
  
    }
    
    //make sure you override the equals method, neccessaryy!! make it so that equality means that it is the same in contents
    
    
    }
    private boolean vacuum_legal_move(Vacuum vac, char nextMove) {int vac_row = vac.getRow(); int vac_col = vac.getColumn(); 
    if (nextMove =='w'){Sprite up_sprite_tile = this.grid.getCell(vac_row+1,vac_col); if (up_sprite_tile instanceof Wall || up_sprite_tile instanceof Vacuum){return false;}
    else if (up_sprite_tile instanceof Dirt){Sprite under1 = vac.getUnder(); if (vac.clean(Constants.DIRT_SCORE)){this.dirts.remove(up_sprite_tile);this.grid.setCell(vac_row+1, vac_col, vac); vac.setUnder(new CleanHallway(' ',vac_row+1,vac_col));this.grid.setCell(vac_row, vac_col, under1);vac.moveTo(vac_row+1, vac_col);}
    else {this.grid.setCell(vac_row, vac_col, under1); this.grid.setCell(vac_row+1, vac_col, vac); vac.setUnder(up_sprite_tile); vac.moveTo(vac_row+1, vac_col);} } else if (up_sprite_tile instanceof DustBall) {
    	Sprite under1 = vac.getUnder(); if (vac.clean(Constants.DUST_BALL_SCORE)){this.dirts.remove(up_sprite_tile);this.grid.setCell(vac_row+1, vac_col, vac); vac.setUnder(new CleanHallway(' ',vac_row+1,vac_col));this.grid.setCell(vac_row, vac_col, under1);vac.moveTo(vac_row+1, vac_col);}
        else {this.grid.setCell(vac_row, vac_col, under1); this.grid.setCell(vac_row+1, vac_col, vac); vac.setUnder(up_sprite_tile); vac.moveTo(vac_row+1, vac_col);}
    } else if (up_sprite_tile instanceof CleanHallway) {Sprite under1 = vac.getUnder(); this.grid.setCell(vac_row, vac_col, under1); this.grid.setCell(vac_row+1, vac_col, vac); vac.setUnder(up_sprite_tile); vac.moveTo(vac_row+1, vac_col);} else{Sprite under1 = vac.getUnder(); this.grid.setCell(vac_row, vac_col, under1); this.grid.setCell(vac_row+1, vac_col, vac); vac.setUnder(up_sprite_tile); vac.moveTo(vac_row+1, vac_col); vac.empty();} }
    
    else if (nextMove == 's') {Sprite down_sprite_tile = this.grid.getCell(vac_row-1,vac_col); if (down_sprite_tile instanceof Wall || down_sprite_tile instanceof Vacuum){return false;}
    else if (down_sprite_tile instanceof Dirt){Sprite under1 = vac.getUnder(); if (vac.clean(Constants.DIRT_SCORE)){this.dirts.remove(down_sprite_tile);this.grid.setCell(vac_row-1,vac_col,vac); vac.setUnder(new CleanHallway(' ',vac_row-1,vac_col));this.grid.setCell(vac_row, vac_col, under1);vac.moveTo(vac_row-1, vac_col);}
    else {this.grid.setCell(vac_row, vac_col, under1); this.grid.setCell(vac_row-1,vac_col,vac); vac.setUnder(down_sprite_tile); vac.moveTo(vac_row-1, vac_col);} } else if (down_sprite_tile instanceof DustBall) {
    	Sprite under1 = vac.getUnder(); if (vac.clean(Constants.DUST_BALL_SCORE)){this.dirts.remove(down_sprite_tile);this.grid.setCell(vac_row-1,vac_col,vac); vac.setUnder(new CleanHallway(' ',vac_row-1,vac_col));this.grid.setCell(vac_row, vac_col, under1);vac.moveTo(vac_row-1, vac_col);}
        else {this.grid.setCell(vac_row, vac_col, under1); this.grid.setCell(vac_row-1,vac_col,vac); vac.setUnder(down_sprite_tile); vac.moveTo(vac_row-1, vac_col);}
    } else if (down_sprite_tile instanceof CleanHallway) {Sprite under1 = vac.getUnder(); this.grid.setCell(vac_row, vac_col, under1); this.grid.setCell(vac_row-1,vac_col,vac); vac.setUnder(down_sprite_tile); vac.moveTo(vac_row-1, vac_col);} else{Sprite under1 = vac.getUnder(); this.grid.setCell(vac_row, vac_col, under1); this.grid.setCell(vac_row-1,vac_col,vac); vac.setUnder(down_sprite_tile); vac.moveTo(vac_row-1, vac_col); vac.empty();}}
    
    else if (nextMove == 'a'){Sprite left_sprite_tile = this.grid.getCell(vac_row,vac_col-1); if (left_sprite_tile instanceof Wall || left_sprite_tile instanceof Vacuum){return false;}
    else if (left_sprite_tile instanceof Dirt){Sprite under1 = vac.getUnder(); if (vac.clean(Constants.DIRT_SCORE)){this.dirts.remove(left_sprite_tile);this.grid.setCell(vac_row, vac_col-1,vac); vac.setUnder(new CleanHallway(' ',vac_row,vac_col-1));this.grid.setCell(vac_row, vac_col, under1);vac.moveTo(vac_row, vac_col-1);}
    else {this.grid.setCell(vac_row, vac_col, under1); this.grid.setCell(vac_row, vac_col-1,vac); vac.setUnder(left_sprite_tile); vac.moveTo(vac_row, vac_col-1);} } else if (left_sprite_tile instanceof DustBall) {
    	Sprite under1 = vac.getUnder(); if (vac.clean(Constants.DUST_BALL_SCORE)){this.dirts.remove(left_sprite_tile);this.grid.setCell(vac_row, vac_col-1,vac); vac.setUnder(new CleanHallway(' ',vac_row,vac_col-1));this.grid.setCell(vac_row, vac_col, under1);vac.moveTo(vac_row, vac_col-1);}
        else {this.grid.setCell(vac_row, vac_col, under1); this.grid.setCell(vac_row, vac_col-1,vac); vac.setUnder(left_sprite_tile); vac.moveTo(vac_row, vac_col-1);}
    } else if (left_sprite_tile instanceof CleanHallway) {Sprite under1 = vac.getUnder(); this.grid.setCell(vac_row, vac_col, under1); this.grid.setCell(vac_row, vac_col-1,vac); vac.setUnder(left_sprite_tile); vac.moveTo(vac_row, vac_col-1);} else{Sprite under1 = vac.getUnder(); this.grid.setCell(vac_row, vac_col, under1); this.grid.setCell(vac_row, vac_col-1,vac); vac.setUnder(left_sprite_tile); vac.moveTo(vac_row, vac_col-1); vac.empty();}}
    
    else {Sprite right_sprite_tile = this.grid.getCell(vac_row,vac_col+1); if (right_sprite_tile instanceof Wall || right_sprite_tile instanceof Vacuum){return false;}
    else if (right_sprite_tile instanceof Dirt){Sprite under1 = vac.getUnder(); if (vac.clean(Constants.DIRT_SCORE)){this.dirts.remove(right_sprite_tile);this.grid.setCell(vac_row,vac_col+1,vac); vac.setUnder(new CleanHallway(' ',vac_row,vac_col+1));this.grid.setCell(vac_row,vac_col,under1);vac.moveTo(vac_row, vac_col+1);}
    else {this.grid.setCell(vac_row,vac_col,under1); this.grid.setCell(vac_row,vac_col+1,vac); vac.setUnder(right_sprite_tile); vac.moveTo(vac_row, vac_col+1);} } else if (right_sprite_tile instanceof DustBall) {
    	Sprite under1 = vac.getUnder(); if (vac.clean(Constants.DUST_BALL_SCORE)){this.dirts.remove(right_sprite_tile);this.grid.setCell(vac_row,vac_col+1,vac); vac.setUnder(new CleanHallway(' ',vac_row,vac_col+1));this.grid.setCell(vac_row,vac_col,under1);vac.moveTo(vac_row, vac_col+1);}
        else {this.grid.setCell(vac_row,vac_col, under1); this.grid.setCell(vac_row,vac_col+1,vac); vac.setUnder(right_sprite_tile); vac.moveTo(vac_row, vac_col+1);}
    } else if (right_sprite_tile instanceof CleanHallway) {Sprite under1 = vac.getUnder(); this.grid.setCell(vac_row,vac_col,under1); this.grid.setCell(vac_row,vac_col+1,vac); vac.setUnder(right_sprite_tile); vac.moveTo(vac_row, vac_col+1);} else{Sprite under1 = vac.getUnder(); this.grid.setCell(vac_row,vac_col,under1); this.grid.setCell(vac_row,vac_col+1,vac); vac.setUnder(right_sprite_tile); vac.moveTo(vac_row, vac_col+1); vac.empty();} }
    return true;} //only going to be called when the tile is in range of grid but perhaps the tile cannot be stepped on
    
    public Grid<Sprite> getGrid() {return this.grid;}  
    public Vacuum getVacuumOne() {return vacuum1;}
        
    
    
    
    public Vacuum getVacuumTwo() {return vacuum2;}
        
    
    
    
    public int getNumRows() {return this.grid.getNumRows();}
    public int getNumColumns() {return this.grid.getNumColumns();}
    public Sprite getSprite(int i, int j) {
    {return this.grid.getCell(i,j);}
    }
    public int getWinner() {if (vacuum1.getScore() > vacuum2.getScore()){return 1;}
    else  {return 2;}}
    
    public boolean move(char nextMove) {if 
    	(Arrays.asList(vacuum1_moves).contains(Character.toString(nextMove))) {Vacuum vac_1 = this.getVacuumOne();  int vac_row = vac_1.getRow(); int grid_row = this.grid.getNumRows(); int grid_col = this.grid.getNumColumns();
    	int vac_col = vac_1.getColumn(); if (nextMove == 'a'){if (vac_col == 0){return false;} else{boolean result = this.vacuum_legal_move(vac_1, nextMove); this.DustballMove(); return result;}} else if(nextMove=='d'){if(vac_col==grid_col-1){return false;} else{boolean result = this.vacuum_legal_move(vac_1, nextMove); this.DustballMove(); return result;}} else if(nextMove == 'w'){if (vac_row==0){return false;} else{boolean result = this.vacuum_legal_move(vac_1, nextMove); this.DustballMove(); return result;}} else{if (vac_row == grid_row-1){return false;} 
    	else{boolean result = this.vacuum_legal_move(vac_1, nextMove); this.DustballMove(); return result;}}}
    
    else if 
	(Arrays.asList(vacuum2_moves).contains(Character.toString(nextMove))) {Vacuum vac_2 = this.getVacuumTwo();  int vac_row = vac_2.getRow(); int grid_row = this.grid.getNumRows(); int grid_col = this.grid.getNumColumns();
	int vac_col = vac_2.getColumn(); if (nextMove == 'j'){if (vac_col == 0){return false;} else{boolean result = this.vacuum_legal_move(vac_2, nextMove); this.DustballMove(); return result;}} else if(nextMove=='l'){if(vac_col==grid_col-1){return false;} else{boolean result = this.vacuum_legal_move(vac_2, nextMove); this.DustballMove(); return result;}} else if(nextMove == 'i'){if (vac_row==0){return false;} else{boolean result = this.vacuum_legal_move(vac_2, nextMove); this.DustballMove(); return result;}} else{if (vac_row == grid_row-1){return false;} 
	else{boolean result = this.vacuum_legal_move(vac_2, nextMove); this.DustballMove(); return result;}}}  //vacuum_legal_move does all the work.  
    
    else {this.DustballMove(); return false; }
    }  
    //vacuum can only go on dumpsters, dirts, and cleanhallway
    public boolean gameOver() {if (this.dirts.isEmpty()){return true;} else{return false;}}  
}
